% TODO:
%  - submenus / menu trees
%  - i18n/L10n
%  - resolution dependend fonts, indentation and line spacing
%  - icons
%  - help/description
%  - menu entry specific font and line spacing
%  - different alignments (left, center)
%

%% include properties.inc
%% include string.inc
%% include video.inc
%% include xml.inc

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% Some constants we probably need.
%
/true 0 0 eq def
/false 0 0 ne def

% some key codes
/keyEsc       0x0000001b def
/keyEnter     0x0000000d def
/keyUp        0x48000000 def
/keyLeft      0x4b000000 def
/keyRight     0x4d000000 def
/keyDown      0x50000000 def

% type values
/t_none  0 def
/t_int   1 def
/t_str   4 def
/t_arr  10 def
/t_end  11 def
/t_ptr  12 def

% undefined (nil) value
/.undef 0 t_none settype def

% end token, stops execution
/.end 0 t_end settype def


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% Convert integer to pointer.
%
% ( int1 -- ptr1 )
%
/cvp { t_ptr settype } def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% Convert pointer to integer
%
% ( ptr1 -- int1 )
%
/cvn { t_int settype } def

/string {
  1 add malloc 4 settype
} def

/sprintf {
  dup t_ptr settype length exch snprintf
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% Input event handling.
%
% ( key -- input_buffer menu_entry action )
%
% key
%  bit 0-7      ascii
%  bit 8-15     scan code
%  bit 16-32    status bits (ctrl, shift...)
%
% action
%    0:         ok, stay in input loop
%    1:         switch to text mode (that is, continue with the non-gfxboot bootloader interface)
%  >=2:         boot
%
% Notes:
%  - key = 0 indicates the bootloader timeout is up.
%  - input_buffer is the command line that you would have normally entered in the bootloader.
%    note that for syslinux it must start with the menu label string but not for grub
%  - menu_entry is the number of the menu entry you want to boot
%
/KeyEvent {
  % pre-process keycode a bit
  dup 0xff00 and 16 shl exch 0xff and dup 0xe0 eq { pop 0 } if add
  dup 0xff and { 0xff and } if
  /key exch def

  % 'key' now holds the ASCII code for 'normal' keys and the scan code in the
  % upper 8 bits if there is no ASCII code (e.g. F-keys, cursor keys)

  % process key events...
  key keyDown eq {
    menu.selected_index menu.entries length 1 sub lt {
      menu.selected_index menu.deselect
      /menu.selected_index menu.selected_index 1 add def
      menu.selected_index menu.select
    } if
  } if

  key keyUp eq {
    menu.selected_index 0 gt {
      menu.selected_index menu.deselect
      /menu.selected_index menu.selected_index 1 sub def
      menu.selected_index menu.select
    } if
  } if

  key keyEnter eq {
    menu.entries menu.selected_index get
    % check menu entry type
    dup 0 get
    dup menu.type.start eq {
      % this is a start entry
      % remove type from stack
      pop
      handle_start_menu_entry
      return
    } {
      dup menu.type.config eq {
        % this is a config entry
        % remove type from stack
        pop
        handle_config_menu_entry
      } {
        menu.type.option eq {
          handle_option_menu_entry
        } if
     } ifelse
    } ifelse
  } if

 "" 0 0
} def


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% gets the selected index of a config options menu
%
% ( array -- int )
%
% array: the config options menu
%
% int: the selected index
%
/get_selected_option_index {
  0
  exch
  {
    4 get {
      return
    } if
    1 add
  } forall
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% converts a config into a menu structure
%
% ( string -- array )
%
% string: the config id
%
% array: the menu structure
%
/config_to_menu {
  [
    exch
    % search config
    dup get_configuration
    % loop over all config options
    config.options.index get {
      [
        exch
        % option menus are arrays with the following fields:
        %   0: type == menu.type.option
        %   1: config id (string, config id)
        %   2: option id (string, option id)
        %   3: text (string, config description)
        %   4: selected (boolean)

        % type
        menu.type.option
        exch
        % config id
        3 index
        exch 
        % option id
        dup 0 get
        % text
        exch dup 1 get
        % selected
        exch 4 get
      ]
      % keep config id on TOS
      exch
    } forall
    % remove config id from stack (no longer needed)
    pop
  ]
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% handles a start menu entry
%
% ( array -- string int int )
%
% array: the selected start menu entry
%
% string: the label and append line for syslinux
% int: the index for syslinux
% int: the action for syslinux (always 2 == boot)
%
/handle_start_menu_entry {
  % get menu label
  dup 3 get

  % check, if the config should be appended to the label
  exch dup 4 get {
    % yes, append config to label

    % get currently selected config options and
    % assemble them in one large append line
    /append_line 0 string def
    configurations {
      % get options array of config
      config.options.index get {
        % only use selected options
        dup 4 get {
          % option is selected
          % get option specific append line
          2 get
          % concatenate with global append line
          append_line " " concatenate_strings
          exch
          concatenate_strings
          /append_line exch def
        } {
          % option is not selected
          pop
        } ifelse
      } forall
    } forall

    % concatenate label and append line
    exch append_line concatenate_strings
    % get menu entry back to top of stack
    exch
  } if

  % get menu index
  2 get 

  % "2" means that we want to boot
  2
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% handles a config menu entry
%
% ( array -- )
%
% array: the selected config menu entry
%
/handle_config_menu_entry {
  % erase existing menu
  menu.erase

  % paint config options menu
  1 get
  config_to_menu
  /menu.entries exch def
  paint_menu

  % remember config menu index for later use
  % (when returning after selecting an option)
  /config.menu.index menu.selected_index def

  %find and highlight selected option
  menu.entries get_selected_option_index
  /menu.selected_index exch def
  menu.selected_index menu.select
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% handles a config option menu entry
%
% ( array -- )
%
% array: the selected config option menu entry
%
/handle_option_menu_entry {
  % update configuration
  % get option id
  dup 2 get
  % get configuration
  exch 1 get get_configuration
  % get config trigger
  dup config.trigger.index get
  /tmp_config_trigger exch def
  % loop through all configuration options
  config.options.index get {
    % get id
    dup 0 get
    % check against id of option menu entry
    2 index eq {
      % this is the selected option
      dup 4 true put
      % get option trigger
      3 get
      /tmp_option_trigger exch def
    } {
      % this is not the selected option
      4 false put
    } ifelse
  } forall
  % remove option id from TOS
  pop

  % handle config trigger (if any)
  tmp_config_trigger "" ne {
    tmp_config_trigger get_configuration
    % loop through all configuration options
    config.options.index get {
      % get id
      dup 0 get
      % check against option trigger id
      tmp_option_trigger eq {
        % this is the selected option
        4 true put
      } {
        % this is not the selected option
        4 false put
      } ifelse
    } forall
  } if

  % repaint main menu
  menu.erase
  /menu.entries main.menu def
  paint_menu

  % select current configuration 
  /menu.selected_index config.menu.index def
  menu.selected_index menu.select
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% gets the x offset to center a string
%
% ( string -- int )
%
% string: the string to show centered
%
% int: the x value to center the string
%
/centered_x_value {
  strsize pop
  screen.size pop
  exch sub
  2 div
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% shows a text centered on screen
%
% ( int string -- )
%
% int: y value of the cursor position
% string: the string to show centered
%
/show_centered {
  dup centered_x_value
  rot moveto
  show
} def
 
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% add highlight to menu item.
%
% ( int -- )
%
% int: the index to highlight
%
/menu.select {
  dup

  % move to menu position
  dup menu.entries exch get
  menu_to_text
  centered_x_value
  exch menu.dy mul menu.y add
  % keep position copy on stack so that we can jump back later
  1 index
  1 index
  moveto

  % paint text in highlighted color
  0xFFFFFF setcolor
  rot
  menu.entries exch get
  menu_to_text
  dup string_region_reset show
  % jump back
  moveto
 
  % paint highlight marker
  ">" dup strsize pop neg 10 sub 0 rmoveto
  show
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% remove highlight of menu item.
%
% ( int -- )
%
% int: the index where to remove the highlight
%
/menu.deselect {
  dup

  % move to menu position
  dup menu.entries exch get
  menu_to_text
  centered_x_value
  exch menu.dy mul menu.y add
  % keep position copy on stack so that we can jump back later
  1 index
  1 index
  moveto

  % paint text in normal color
  0x000000 setcolor
  rot
  menu.entries exch get
  menu_to_text
  dup string_region_reset show
  % jump back
  moveto
 
  % remove highlight marker
  ">" dup strsize pop neg 10 sub 0 rmoveto
  currentpoint rot strsize image
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% erases the currently shown menu from screen
%
% ( -- )
%
%
/menu.erase {
  % erase highlight marker
  menu.entries menu.selected_index get
  menu_to_text
  centered_x_value
  menu.selected_index menu.dy mul menu.y add
  moveto
  ">" dup strsize pop neg 10 sub 0 rmoveto
  currentpoint rot strsize image

  % erase all menu entries
  /y_offset menu.y def
  menu.entries {
    menu_to_text
    dup centered_x_value
    y_offset
    moveto
    string_region_reset
    /y_offset y_offset menu.dy add def
  } forall
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% shows the image region of a string
%
% ( string -- )
%
% string: the string whose image region is repainted
%
/string_region_reset {
  currentpoint rot strsize image
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% gets a configuration by id
%
% ( string -- array )
%
% string: the configuration id
%
% array: the configuration
%
/get_configuration {
  configurations {
    dup config.id.index get
    2 index eq {
      % this is the config we were searching for
      % remove config id from stack
      exch pop
      return
    } {
      % this is another config...
      % just remove it from the stack
      pop
    } ifelse
  } forall
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% gets the textual representation of the selected option of a configuration
%
% ( array -- string )
%
% array: a configuration entry
%
% string: the textual representation of the selected option
%
/get_selected_option_text {
  % loop over all config options
  config.options.index get {
    % check, if option is selected
    dup 4 get {
      % selected option found, leave text on stack
      1 get return
    } {
      % option not selected, remove from stack
      pop
    } ifelse
  } forall
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% gets the textual representation of a menu entry
%
% ( array -- string )
%
% array: a menu entry
%
% string: the textual representation of the menu entry
%
/menu_to_text {
  % check menu entry type
  dup 0 get
  dup menu.type.start eq {
    % this is a start entry
    % remove type from stack
    pop
    % leave start menu text on stack
    1 get
  } {
    dup menu.type.config eq {
      % this is a config entry
      % remove type from stack
      pop
      % get configuration by id
      1 get get_configuration
      % get configuration text
      dup config.text.index get
      % show currently selected option
      ": " concatenate_strings
      exch
      get_selected_option_text
      concatenate_strings
    } {
      menu.type.option eq {
        % this is an option entry
        % get option menu text
        3 get
      } if
    } ifelse
  } ifelse
} def

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% paints a menu on screen
%
% ( -- )
%
/paint_menu {
  menu.entries
  menu.font findfile setfont
  0x000000 setcolor
  /y_offset menu.y def
  {
    menu_to_text
    y_offset exch show_centered
    /y_offset y_offset menu.dy add def
  } forall
} def

% set a good video mode and a splash screen
trymodes
paint_splash

% parse xml file
"xmlboot.config" findfile
parse_xml_file
/xml_structure exch def

% paint version info in the lower left screen corner
"font_size_10.fnt" findfile setfont
0x000000 setcolor
xml_structure "system" get_entity_child "version" get_attribute_value
dup strsize exch pop
screen.size exch pop
exch sub
10 sub
10 exch
moveto
show

% some config specifig constants
/config.id.index      0 def
/config.text.index    1 def
/config.trigger.index 2 def
/config.options.index 3 def

% get config options from XML structure
%
% configurations are arrays with the following fields:
%   0: id (string)
%   1: text (string)
%   2: trigger_config (string, another configuration that gets triggered)
%   3: options (array)
xml_structure "configs" get_entity_child
/xmlboot_config exch def
/configurations
[
  xmlboot_config get_entity_children {
    dup gettype t_arr eq {
      % child is another entity
      % check, if entitiy is supported
      dup get_entity_name "config" eq {
        [
          exch dup "id" get_attribute_value
          exch dup "text" get_attribute_value
          exch dup "trigger_config" get_attribute_value
          exch
          % parse all options
          [
            exch get_entity_children {
              dup gettype t_arr eq {
                dup get_entity_name "option" eq {
                  % configuration options are arrays with the following fields:
                  %   0: id (string)
                  %   1: text (string)
                  %   2: append (string)
                  %   3: trigger_option (string)
                  %   4: selected (boolean)
                  [
                    exch dup "id" get_attribute_value
                    exch dup "text" get_attribute_value
                    exch dup "append" get_attribute_value
                    exch dup "trigger_option" get_attribute_value
                    exch "selected" get_attribute_value "true" eq {
                      true
                    } {
                      false
                    } ifelse
                  ]
                } {
                  % entity is not supported
                  pop
                } ifelse
              } {
                % child is just some text
                pop
              } ifelse
            } forall
          ]
        ]
      } {
        % entity is not supported
        pop
      } ifelse
    } {
      % child is just some text
      pop
    } ifelse
  } forall
] def

% menu variables
/menu.selected_index 0 def
/menu.type.start  0 def
/menu.type.config 1 def
/menu.type.option 2 def

% get menu from XML structure
%
% start menus are arrays with the following fields:
%   0: type == menu.type.start
%   1: text (string, the text to display in the start menu)
%   2: index (string, the index in the syslinux config file to start)
%   3: label (string, the label in the syslinux config file to start)
%   4: append_config (bool, if the config should be appended to the label when booting)
%
% config menus are arrays with the following fields:
%   0: type == menu.type.config
%   1: id (string, config id)
%   
xml_structure "menu" get_entity_child
/xmlboot_menu exch def
/menu.font xmlboot_menu "font" get_attribute_value def
/menu.y xmlboot_menu "y" get_attribute_value string_to_int def
/menu.dy xmlboot_menu "dy" get_attribute_value string_to_int def
/menu.entries
[
  xmlboot_menu get_entity_children {
    dup gettype t_arr eq {
      % child is another entity
      % check, if entitiy is supported
      dup get_entity_name "start" eq {
        [
          exch
          menu.type.start
          exch dup "text" get_attribute_value
          exch dup "index" get_attribute_value string_to_int
          exch dup "label" get_attribute_value
          exch "append_config" get_attribute_value
          "true" eq {
            true
          } {
            false
          } ifelse
        ]
      } {
        dup get_entity_name "config" eq {
          [
            exch
            menu.type.config
            exch "id" get_attribute_value
          ]
        } {
          % entity is not supported
          pop
        } ifelse
      } ifelse
    } {
      % child is just some text
      pop
    } ifelse
  } forall
] def

/main.menu menu.entries def

% paint menu texts
paint_menu

% select first entry in menu list
menu.selected_index menu.select

% say we're fine ('false' tells bootloader not to use gfxboot)
true
