% HINT:
%  - findfile seems to have a bug that only files with names that are longer than 12 characters
%    are found (maybe this has something to do with the "stoneage" 8.3 file name limit!?)
%
% TODO:
%  - menu item indentation (for grouping config options under start menu entries)
%  - help/description (with screenshots?, also how to use this menu (up, down, enter...))
%  - check layout configuration on higher resolutions
%  - initial config_to_submenu (when reading menu structure), not dynamically at runtime...???
%  - better error handling
%
% test with:
%  $ gfxboot -p -b isolinux -a bootlogo
%

%% include constants.inc
%% include gettext.inc
%% include input.inc
%% include menu.inc
%% include properties.inc
%% include string.inc
%% include timeout.inc
%% include video.inc
%% include xml.inc

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% converts an integer to a pointer
%
% ( int1 -- ptr1 )
%
/cvp { t_ptr settype } def

% buffer for holding the edit input string
/edit_input_buffer 1024 string def

% parse xml config file
"xmlboot.config" findfile dup
parse_xml_file
/xml_structure exch def
free

% set a good video mode and a splash screen
try_video_modes
% remember default image
/default_image currentimage def
% store current image as default background image
0 0 moveto screen.size savescreen
/default_background exch def

% get timeout options from xml structure
xml_structure "timeout" get_entity_child
dup /timeout.color exch "color" get_attribute_value string_to_int def
dup /timeout.format_singular exch "format_singular" get_entity_child get_entity_children 0 get gettext def
dup /timeout.format_plural exch "format_plural" get_entity_child get_entity_children 0 get gettext def
/timeout.string timeout.format_plural length 10 add string def
get_entity_children {
  dup gettype t_arr eq {
    dup get_entity_name "layout" eq {
      dup "width" get_attribute_value string_to_int
      exch dup "height" get_attribute_value string_to_int
      rot exch screen.size rot eq rot rot eq and {
        % layout config for current video mode found
        dup "x" get_attribute_value string_to_int
        /timeout.x exch def
        dup "y" get_attribute_value string_to_int
        /timeout.y exch def
        "font" get_attribute_value findfile
        /timeout.fontfile exch def
        exit
      } {
        % a layout config for another video mode (ignore)
        pop
      } ifelse
    } {
      % entity not (yet) supported
      pop
    } ifelse
  } {
    % child entry was just some text
    pop
  } ifelse
} forall
timeout.x 0 t_none settype eq {
  % the layout for the timeout for the current video mode
  % was not found in config file!
  "timeout layout missing!" dtrace pop
} if

% get system info properties from xml structure
xml_structure "system" get_entity_child
get_entity_children {
  dup gettype t_arr eq {
    dup get_entity_name "text" eq {
      get_entity_children 0 get
      /system_info exch def
    } {
      dup get_entity_name "layout" eq {
        dup "width" get_attribute_value string_to_int
        exch dup "height" get_attribute_value string_to_int
        rot exch screen.size rot eq rot rot eq and {
          % layout config for current video mode found
          dup "x" get_attribute_value string_to_int
          /system_info_x exch def
          dup "y" get_attribute_value string_to_int
          /system_info_y exch def
          "font" get_attribute_value findfile
          /system_info_font_file exch def
          exit
        } {
          % a layout config for another video mode (ignore)
          pop
        } ifelse
      } {
        % entity not (yet) supported
        pop
      } ifelse
    } ifelse
  } {
    % child entry was just some text
    pop
  } ifelse
} forall
system_info_x 0 t_none settype eq {
  % the layout for the system information for the current video mode
  % was not found in config file!
  "system info layout missing!" dtrace pop
} if

% get breadcrumb options from xml file
xml_structure "breadcrumbs" get_entity_child
dup "color" get_attribute_value string_to_int
/breadcrumbs.color exch def
dup "delimiter" get_attribute_value
/breadcrumbs.delimiter exch def
get_entity_children {
  dup gettype t_arr eq {
    dup get_entity_name "layout" eq {
      dup "height" get_attribute_value string_to_int
      screen.size exch pop eq {
        % layout config for current screen height found
        dup "y" get_attribute_value string_to_int
        /breadcrumbs.y exch def
        "font" get_attribute_value findfile
        /breadcrumbs.font_file exch def
        exit
      } {
        % a layout config for another screen height (ignore)
        pop
      } ifelse
    } {
      % not (yet) supported
      pop
    } ifelse
  } {
    % child entry was just some text
    pop
  } ifelse
} forall
breadcrumbs.y 0 t_none settype eq {
  % the layout for the breadcrumbs for the current screen height
  % was not found in config file!
  "breadcrumbs layout missing!" dtrace pop
} if

% some config specific constants
/config.index.id      0 def
/config.index.text    1 def
/config.index.trigger 2 def
/config.index.options 3 def

% get configurations from XML structure
%
% configurations are arrays with the following fields:
%   0: id (string)
%   1: text (string)
%   2: trigger_config (string, another configuration that gets triggered)
%   3: options (array)
xml_structure "configs" get_entity_child
/configurations
[
  rot
  get_entity_children {
    dup gettype t_arr eq {
      % child is another entity
      % check, if entity is supported
      dup get_entity_name "config" eq {
        [
          exch dup "id" get_attribute_value
          /tmp_config_id exch def
          tmp_config_id
          % get text from child element
          exch dup "text" get_entity_child get_entity_children 0 get
          exch dup "trigger_config" get_attribute_value
          exch
          % parse all options
          [
            exch get_entity_children {
              dup gettype t_arr eq {
                dup get_entity_name "option" eq {
                  % configuration options are arrays with the following fields:
                  %   0: id (string)
                  %   1: text (string)
                  %   2: append (string)
                  %   3: trigger_option (string)
                  %   4: selected (boolean)
                  [
                    exch dup "id" get_attribute_value
                    /tmp_option_id exch def
                    tmp_option_id
                    % get text from child element
                    exch dup get_entity_children 0 get
                    exch dup "append" get_attribute_value
                    exch dup "trigger_option" get_attribute_value
                    exch "selected" get_attribute_value "true" eq {
                      true
                      % gettext support
                      tmp_config_id "language" eq {
                        tmp_option_id ".translation" concatenate_strings
                        read_translation_file
                      } if
                    } {
                      false
                    } ifelse
                  ]
                } {
                  % entity is not supported
                  pop
                } ifelse
              } {
                % child is just some text
                pop
              } ifelse
            } forall
          ]
        ]
      } {
        % entity is not supported
        pop
      } ifelse
    } {
      % child is just some text
      pop
    } ifelse
  } forall
] def

% some config option specific constants
/option.index.id                 0 def
/option.index.text               1 def
/option.index.append_selected    2 def
/option.index.append_nonselected 3 def
/option.index.selected           4 def

% get options from XML structure
%
% options are arrays with the following fields:
%   0: id (string)
%   1: text (string)
%   2: append_selected (string)
%   3: append_nonselected (string)
%   4: selected (boolean)
xml_structure "options" get_entity_child
/options
[
  rot
  get_entity_children {
    dup gettype t_arr eq {
      % child is another entity
      % check, if entity is supported
      dup get_entity_name "option" eq {
        [
          exch dup "id" get_attribute_value
          % get text from child element
          exch dup get_entity_children 0 get
          exch dup "append_selected" get_attribute_value
          exch dup "append_nonselected" get_attribute_value
          exch "selected" get_attribute_value "true" eq {
            true
          } {
            false
          } ifelse
        ]
      } {
        % entity is not supported
        pop
      } ifelse
    } {
      % child is just some text
      pop
    } ifelse
  } forall
] def

% get menu from XML structure
xml_structure "menu" get_entity_child
dup "color" get_attribute_value string_to_int
/menu.color exch def
dup "selected_color" get_attribute_value string_to_int
/menu.selected_color exch def
dup "rectangle_color" get_attribute_value string_to_int
/menu.rectangle_color exch def
parse_menu
/current.menu exch def

% custom options
xml_structure "custom_options" get_entity_child
"text" get_attribute_value
"%s" edit_input_buffer sprintf

% support for breadcrumbs
% a breadrumb is an array with the following fields:
%   0: previous breadcrumb
%   1: this menu
%   2: the index of this menu in the previous menu
/last_breadcrumb [
  0
  current.menu
  0
] def

% paint menu texts
% !!! last_breadcrumb and edit_input_buffer must already be defined for paint_menu to work !!!
paint_menu

% select first entry in menu list
menu.selected_index menu.select

% say we're fine ('false' tells bootloader not to use gfxboot)
true
