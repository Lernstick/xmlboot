% HINT:
%  - findfile seems to have a bug that only files with names that are longer than 12 characters
%    are found (maybe this has something to do with the "stoneage" 8.3 file name limit!?)
%
% TODO:
%  - use savescreen/restorescreen?
%  - icon insets in xml file
%  - i18n/L10n
%  - resolution dependend fonts, indentation and line spacing
%  - help/description (with screenshots?)
%  - menu entry specific font and line spacing
%
% test with:
%  $ gfxboot -p -b isolinux -a bootlogo
%

%% include constants.inc
%% include input.inc
%% include menu.inc
%% include properties.inc
%% include string.inc
%% include video.inc
%% include xml.inc

% set a good video mode and a splash screen
trymodes
paint_splash
% remember default image
/default_image currentimage def

% parse xml file
"xmlboot.config" findfile dup
parse_xml_file
/xml_structure exch def
free

% paint version info in the lower left screen corner
xml_structure "system" get_entity_child "version" get_attribute_value
/version_info exch def

% some config specific constants
/config.index.id      0 def
/config.index.text    1 def
/config.index.trigger 2 def
/config.index.options 3 def

% get configurations from XML structure
%
% configurations are arrays with the following fields:
%   0: id (string)
%   1: text (string)
%   2: trigger_config (string, another configuration that gets triggered)
%   3: options (array)
xml_structure "configs" get_entity_child
/configurations
[
  rot
  get_entity_children {
    dup gettype t_arr eq {
      % child is another entity
      % check, if entitiy is supported
      dup get_entity_name "config" eq {
        [
          exch dup "id" get_attribute_value
          exch dup "text" get_attribute_value
          exch dup "trigger_config" get_attribute_value
          exch
          % parse all options
          [
            exch get_entity_children {
              dup gettype t_arr eq {
                dup get_entity_name "option" eq {
                  % configuration options are arrays with the following fields:
                  %   0: id (string)
                  %   1: text (string)
                  %   2: append (string)
                  %   3: trigger_option (string)
                  %   4: selected (boolean)
                  [
                    exch dup "id" get_attribute_value
                    exch dup "text" get_attribute_value
                    exch dup "append" get_attribute_value
                    exch dup "trigger_option" get_attribute_value
                    exch "selected" get_attribute_value "true" eq {
                      true
                    } {
                      false
                    } ifelse
                  ]
                } {
                  % entity is not supported
                  pop
                } ifelse
              } {
                % child is just some text
                pop
              } ifelse
            } forall
          ]
        ]
      } {
        % entity is not supported
        pop
      } ifelse
    } {
      % child is just some text
      pop
    } ifelse
  } forall
] def

% some config specific constants
/option.index.id                 0 def
/option.index.text               1 def
/option.index.append_selected    2 def
/option.index.append_nonselected 3 def
/option.index.selected           4 def

% get options from XML structure
%
% options are arrays with the following fields:
%   0: id (string)
%   1: text (string)
%   2: append_selected (string)
%   3: append_nonselected (string)
%   4: selected (boolean)
xml_structure "options" get_entity_child
/options
[
  rot
  get_entity_children {
    dup gettype t_arr eq {
      % child is another entity
      % check, if entitiy is supported
      dup get_entity_name "option" eq {
        [
          exch dup "id" get_attribute_value
          exch dup "text" get_attribute_value
          exch dup "append_selected" get_attribute_value
          exch dup "append_nonselected" get_attribute_value
          exch "selected" get_attribute_value "true" eq {
            true
          } {
            false
          } ifelse
        ]
      } {
        % entity is not supported
        pop
      } ifelse
    } {
      % child is just some text
      pop
    } ifelse
  } forall
] def

% get breadcrumb details
xml_structure "breadcrumbs" get_entity_child
dup "y" get_attribute_value string_to_int
/breadcrumbs.y exch def
dup "font" get_attribute_value
/breadcrumbs.font exch def
dup "delimiter" get_attribute_value
/breadcrumbs.delimiter exch def
"color" get_attribute_value string_to_int
/breadcrumbs.color exch def

% get menu from XML structure
xml_structure "menu" get_entity_child
/xmlboot_menu exch def
/menu.font xmlboot_menu "font" get_attribute_value def
/menu.y xmlboot_menu "y" get_attribute_value string_to_int def
/menu.dy xmlboot_menu "dy" get_attribute_value string_to_int def
/menu.color xmlboot_menu "color" get_attribute_value string_to_int def
/menu.selected_color xmlboot_menu "selected_color" get_attribute_value string_to_int def
/menu.rectangle_color xmlboot_menu "rectangle_color" get_attribute_value string_to_int def

xmlboot_menu parse_menu
/menu.entries exch def
/main.menu menu.entries def

% support for breadcrumbs
% a breadrumb is an array with the following fields:
%   0: previous breadcrumb
%   1: this menu
%   2: the index of this menu in the previous menu
/last_breadcrumb [
  0
  main.menu
  0
] def

% paint menu texts
% !!! last_breadcrumb must already be defined for paint_menu to work !!!
paint_menu

% select first entry in menu list
menu.selected_index menu.select

% say we're fine ('false' tells bootloader not to use gfxboot)
true
