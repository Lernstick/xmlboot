% HINT:
%  - findfile seems to have a bug that only files with names that are longer than 12 characters
%    are found (maybe this has something to do with the "stoneage" 8.3 file name limit!?)
%
% TODO:
%  - resolution dependend fonts, indentation and line spacing for all elements (not only for system info)
%  - help/description (with screenshots?, also how to use this menu (up, down, enter...))
%  - menu entry specific font and line spacing (needed for configs with *lots* of options)
%
% test with:
%  $ gfxboot -p -b isolinux -a bootlogo
%

%% include constants.inc
%% include gettext.inc
%% include input.inc
%% include menu.inc
%% include properties.inc
%% include string.inc
%% include timeout.inc
%% include video.inc
%% include xml.inc

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% Convert integer to pointer.
%
% ( int1 -- ptr1 )
%
/cvp { t_ptr settype } def

% buffer for holding the edit input string
/edit_input_buffer 1024 string def

% parse xml config file
"xmlboot.config" findfile dup
parse_xml_file
/xml_structure exch def
free

% set a good video mode and a splash screen
try_video_modes
% remember default image
/default_image currentimage def

% get system info properties
xml_structure "system" get_entity_child
get_entity_children {
  dup gettype t_arr eq {
    dup get_entity_name "text" eq {
      get_entity_children 0 get
      /system_info exch def
    } {
      dup get_entity_name "layout" eq {
        dup "height" get_attribute_value string_to_int
        screen.size exch pop eq {
          % layout config for current screen height found
          dup "x" get_attribute_value string_to_int
          /system_info_x exch def
          dup "y" get_attribute_value string_to_int
          /system_info_y exch def
          "font" get_attribute_value findfile
          /system_info_font_file exch def
        } {
          % a layout config for another screen height (ignore)
          pop
        } ifelse
      } {
        % not (yet) supported
        pop
      } ifelse
    } ifelse
  } {
    % child entry was just some text
    pop
  } ifelse
} forall
system_info_x 0 t_none settype eq {
  % the layout for the system information for the current video mode
  % was not found in config file!
  "system info layout missing!" dtrace pop
} if

% store current image as default background image
0 0 moveto screen.size savescreen
/default_background exch def

% some config specific constants
/config.index.id      0 def
/config.index.text    1 def
/config.index.trigger 2 def
/config.index.options 3 def

% get configurations from XML structure
%
% configurations are arrays with the following fields:
%   0: id (string)
%   1: text (string)
%   2: trigger_config (string, another configuration that gets triggered)
%   3: options (array)
xml_structure "configs" get_entity_child
/configurations
[
  rot
  get_entity_children {
    dup gettype t_arr eq {
      % child is another entity
      % check, if entitiy is supported
      dup get_entity_name "config" eq {
        [
          exch dup "id" get_attribute_value
          /tmp_config_id exch def
          tmp_config_id
          % get text from child element
          exch dup "text" get_entity_child get_entity_children 0 get
          exch dup "trigger_config" get_attribute_value
          exch
          % parse all options
          [
            exch get_entity_children {
              dup gettype t_arr eq {
                dup get_entity_name "option" eq {
                  % configuration options are arrays with the following fields:
                  %   0: id (string)
                  %   1: text (string)
                  %   2: append (string)
                  %   3: trigger_option (string)
                  %   4: selected (boolean)
                  [
                    exch dup "id" get_attribute_value
                    /tmp_option_id exch def
                    tmp_option_id
                    % get text from child element
                    exch dup get_entity_children 0 get
                    exch dup "append" get_attribute_value
                    exch dup "trigger_option" get_attribute_value
                    exch "selected" get_attribute_value "true" eq {
                      true
                      % gettext support
                      tmp_config_id "language" eq {
                        tmp_option_id ".translation" concatenate_strings
                        read_translation_file
                      } if
                    } {
                      false
                    } ifelse
                  ]
                } {
                  % entity is not supported
                  pop
                } ifelse
              } {
                % child is just some text
                pop
              } ifelse
            } forall
          ]
        ]
      } {
        % entity is not supported
        pop
      } ifelse
    } {
      % child is just some text
      pop
    } ifelse
  } forall
] def

% some config specific constants
/option.index.id                 0 def
/option.index.text               1 def
/option.index.append_selected    2 def
/option.index.append_nonselected 3 def
/option.index.selected           4 def

% get options from XML structure
%
% options are arrays with the following fields:
%   0: id (string)
%   1: text (string)
%   2: append_selected (string)
%   3: append_nonselected (string)
%   4: selected (boolean)
xml_structure "options" get_entity_child
/options
[
  rot
  get_entity_children {
    dup gettype t_arr eq {
      % child is another entity
      % check, if entitiy is supported
      dup get_entity_name "option" eq {
        [
          exch dup "id" get_attribute_value
          % get text from child element
          exch dup get_entity_children 0 get
          exch dup "append_selected" get_attribute_value
          exch dup "append_nonselected" get_attribute_value
          exch "selected" get_attribute_value "true" eq {
            true
          } {
            false
          } ifelse
        ]
      } {
        % entity is not supported
        pop
      } ifelse
    } {
      % child is just some text
      pop
    } ifelse
  } forall
] def

% get breadcrumb details
xml_structure "breadcrumbs" get_entity_child
dup "y" get_attribute_value string_to_int
/breadcrumbs.y exch def
dup "font" get_attribute_value
/breadcrumbs.font exch def
dup "delimiter" get_attribute_value
/breadcrumbs.delimiter exch def
"color" get_attribute_value string_to_int
/breadcrumbs.color exch def

% get menu from XML structure
xml_structure "menu" get_entity_child
dup /menu.font exch "font" get_attribute_value def
dup /menu.y exch "y" get_attribute_value string_to_int def
dup /menu.dy exch "dy" get_attribute_value string_to_int def
dup /menu.color exch "color" get_attribute_value string_to_int def
dup /menu.selected_color exch "selected_color" get_attribute_value string_to_int def
dup /menu.rectangle_color exch "rectangle_color" get_attribute_value string_to_int def
dup /menu.icon_inset exch "icon_inset" get_attribute_value string_to_int def
parse_menu
/current.menu exch def

% custom options
xml_structure "custom_options" get_entity_child
"text" get_attribute_value
"%s" edit_input_buffer sprintf

% timeout options
xml_structure "timeout" get_entity_child
dup /timeout.x exch "x" get_attribute_value string_to_int def
dup /timeout.y exch "y" get_attribute_value string_to_int def
dup /timeout.fontfile exch "font" get_attribute_value findfile def
dup /timeout.color exch "color" get_attribute_value string_to_int def
dup /timeout.format_singular exch "format_singular" get_entity_child get_entity_children 0 get gettext def
/timeout.format_plural exch "format_plural" get_entity_child get_entity_children 0 get gettext def
/timeout.string timeout.format_plural length 10 add string def


% support for breadcrumbs
% a breadrumb is an array with the following fields:
%   0: previous breadcrumb
%   1: this menu
%   2: the index of this menu in the previous menu
/last_breadcrumb [
  0
  current.menu
  0
] def

% paint menu texts
% !!! last_breadcrumb and edit_input_buffer must already be defined for paint_menu to work !!!
paint_menu

% select first entry in menu list
menu.selected_index menu.select

% say we're fine ('false' tells bootloader not to use gfxboot)
true
